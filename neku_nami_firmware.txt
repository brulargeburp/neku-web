/**
 * Neku-Nami Control Panel Firmware (v1.1.3 - Configurable Grace Period)
 * 
 * This firmware communicates with the Neku-Nami web application using a
 * human-readable, text-based protocol. It manages two independent circuit breakers
 * via Solid State Relays (SSRs), reads sensor data for each load, and supports 
 * real-time configuration of trip thresholds.
 * 
 * FIRMWARE UPDATE v1.1.3:
 * - The 500ms "grace period" is now configurable per-breaker from the web app.
 *   This allows tuning the trip delay to prevent nuisance trips from inrush current
 *   while giving the user control over this safety parameter.
 * 
 * --- Web App Communication Protocol (Text-based) ---
 * 
 * ---> Outgoing Data Packet to Web App --->
 * A single string line ending in a newline character ('\n').
 * Format: "statusMask|systemCurrent|totalLoadCurrent|load1Current|load2Current"
 * Example: "6|1.55|1.55|0.80|0.75"
 * - statusMask bit 0: Overall status (logical OR of loads)
 * - statusMask bit 1: Load 1 status
 * - statusMask bit 2: Load 2 status
 *
 * <--- Incoming Command Packets from Web App <---
 * Commands are simple strings ending in a newline character ('\n').
 * 1. Toggle State: "T,breakerIndex,newState" 
 * 2. Set Max Current: "M,breakerIndex,maxCurrent"
 * 3. Set Min Current: "m,breakerIndex,minCurrent"
 * 4. Set Grace Period: "G,breakerIndex,gracePeriodMs"
 *    (e.g., "G,1,250" to set Load 1 grace period to 250ms)
 */

// --- Pin Definitions ---
const int load1_currentSensorPin = A0; // Ammeter for Load 1
const int load2_currentSensorPin = A1; // Ammeter for Load 2
const int ssrPinLoad1 = 8;             // SSR for Load 1
const int ssrPinLoad2 = 13;            // SSR for Load 2

// --- State Management (2 Loads) ---
bool breakerIsOn[2] = {false, false};
float maxCurrents[2] = {5.0, 5.0};
float minCurrents[2] = {0.1, 0.1};
unsigned long breakerActivationTime[2] = {0, 0};
unsigned int gracePeriodMs[2] = {500, 500}; // Default grace period is 500ms

// --- Current Sensor Calibration (IMPORTANT!) ---
const float sensorOffset = 2.5; 
const float sensorSensitivity = 0.100;

// --- Communication Timing ---
unsigned long lastSendTime = 0;
const long sendInterval = 100;

void setup() {
  Serial.begin(9600);
  pinMode(ssrPinLoad1, OUTPUT);
  pinMode(ssrPinLoad2, OUTPUT);
  digitalWrite(ssrPinLoad1, LOW);
  digitalWrite(ssrPinLoad2, LOW);
}

void loop() {
  handleSerialCommands();
  updateBreakerLogic();

  if (millis() - lastSendTime >= sendInterval) {
    sendDataPacket();
    lastSendTime = millis();
  }
}

float readCurrent(int pin) {
  int sensorValue = analogRead(pin);
  float voltage = (sensorValue / 1024.0) * 5.0;
  float current = (voltage - sensorOffset) / sensorSensitivity;
  return abs(current);
}

void handleSerialCommands() {
  if (Serial.available() > 0) {
    String command = Serial.readStringUntil('\n');
    command.trim();

    if (command.length() == 0) return;

    char commandType = command.charAt(0);
    String payload = command.substring(2);
    
    int firstComma = payload.indexOf(',');
    if (firstComma == -1) return;

    int webAppIndex = payload.substring(0, firstComma).toInt();
    String valueStr = payload.substring(firstComma + 1);

    if (commandType == 'T') {
      bool newState = (valueStr.toInt() == 1);
      if (webAppIndex == 0) {
        if (!newState) {
          setBreakerState(0, false);
          setBreakerState(1, false);
        }
      } else if (webAppIndex > 0 && webAppIndex < 3) {
        int firmwareIndex = webAppIndex - 1;
        setBreakerState(firmwareIndex, newState);
      }
    } else if (commandType == 'M' || commandType == 'm' || commandType == 'G') {
      if (webAppIndex > 0 && webAppIndex < 3) {
        int firmwareIndex = webAppIndex - 1;
        
        if (commandType == 'M') {
          maxCurrents[firmwareIndex] = valueStr.toFloat();
        } else if (commandType == 'm') {
          minCurrents[firmwareIndex] = valueStr.toFloat();
        } else if (commandType == 'G') {
          gracePeriodMs[firmwareIndex] = valueStr.toInt();
        }
      }
    }
  }
}

void updateBreakerLogic() {
  // Check Load 1
  if (breakerIsOn[0] && (millis() - breakerActivationTime[0] > gracePeriodMs[0])) {
    float load1Current = readCurrent(load1_currentSensorPin);
    if (load1Current >= maxCurrents[0] || (load1Current > 0 && load1Current < minCurrents[0])) {
      setBreakerState(0, false);
    }
  }

  // Check Load 2
  if (breakerIsOn[1] && (millis() - breakerActivationTime[1] > gracePeriodMs[1])) {
    float load2Current = readCurrent(load2_currentSensorPin);
    if (load2Current >= maxCurrents[1] || (load2Current > 0 && load2Current < minCurrents[1])) {
      setBreakerState(1, false);
    }
  }
}

void setBreakerState(int index, bool isOn) {
  if (index < 0 || index >= 2) return;

  if (isOn && !breakerIsOn[index]) {
    breakerActivationTime[index] = millis();
  }

  breakerIsOn[index] = isOn;
  int pin = (index == 0) ? ssrPinLoad1 : ssrPinLoad2;
  digitalWrite(pin, isOn ? HIGH : LOW);
}

void sendDataPacket() {
  uint8_t statusMask = 0;
  
  if (breakerIsOn[0]) { statusMask |= (1 << 1); }
  if (breakerIsOn[1]) { statusMask |= (1 << 2); }
  if (statusMask > 0) { statusMask |= (1 << 0); }

  float load1Current = readCurrent(load1_currentSensorPin);
  float load2Current = readCurrent(load2_currentSensorPin);
  float totalLoadCurrent = load1Current + load2Current;
  float systemCurrent = totalLoadCurrent;
  
  String dataPacket = "";
  dataPacket += String(statusMask);
  dataPacket += "|";
  dataPacket += String(systemCurrent, 2);
  dataPacket += "|";
  dataPacket += String(totalLoadCurrent, 2);
  dataPacket += "|";
  dataPacket += String(load1Current, 2);
  dataPacket += "|";
  dataPacket += String(load2Current, 2);

  Serial.println(dataPacket);
}