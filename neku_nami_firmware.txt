/**
 * Neku-Nami Control Panel Firmware
 * 
 * This firmware communicates with the Neku-Nami web application. It manages
 * four circuit breakers, reads sensor data, and uses a dynamic auto-trip 
 * threshold that can be configured in real-time from the web app.
 * 
 * --- Web App Communication Protocol ---
 * 
 * ---> Outgoing Data Packet to Web App (21 bytes) --->
 * Byte 0:    Status Mask (Bit 0: Overall, Bit 1: Load 1, etc.)
 * Bytes 1-4:   System Voltage (float)
 * Bytes 5-8:   Total Load Voltage (float, placeholder)
 * Bytes 9-12:  Load 1 Voltage (float)
 * Bytes 13-16: Load 2 Voltage (float, placeholder)
 * Bytes 17-20: Load 3 Voltage (float, placeholder)
 *
 * <--- Incoming Command Packets from Web App <---
 * 1. Toggle State (3 bytes):
 *    Byte 0: Command Type (0x01)
 *    Byte 1: Breaker Index (0-3)
 *    Byte 2: New State (0=OFF, 1=ON)
 * 
 * 2. Set Max Voltage (6 bytes):
 *    Byte 0: Command Type (0x02)
 *    Byte 1: Breaker Index (1-3)
 *    Bytes 2-5: Max Voltage (float)
 */

// --- Pin Definitions ---
const int dcLoad_sensorPin = A0;
const int dcArduino_sensorPin = A1;
const int transistorPinLoad1 = 2;
const int transistorPinOverall = 3;
const int transistorPinLoad2 = 4;
const int transistorPinLoad3 = 5;

// --- Command Definitions ---
const uint8_t CMD_TOGGLE_STATE = 0x01;
const uint8_t CMD_SET_MAX_VOLTAGE = 0x02;

// --- State Management ---
bool breakerIsOn[4] = {false, false, false, false};
float maxVoltages[4] = {0.0, 5.0, 5.0, 5.0}; // Default max voltage for Load 1, 2, 3 is 5.0V

// --- Calibration Values ---
const float dcLoad_VoltageSlope = 0.02445;
const float dcLoad_VoltageIntercept = 0.0;
const float dcArduino_VoltageSlope = 0.02445;
const float dcArduino_VoltageIntercept = 0.0;

// --- Communication Timing ---
unsigned long lastSendTime = 0;
const long sendInterval = 100;

void setup() {
  Serial.begin(9600);
  pinMode(transistorPinLoad1, OUTPUT);
  pinMode(transistorPinOverall, OUTPUT);
  pinMode(transistorPinLoad2, OUTPUT);
  pinMode(transistorPinLoad3, OUTPUT);
  // Initialize all circuits to OFF state (HIGH for PNP transistors)
  digitalWrite(transistorPinLoad1, HIGH);
  digitalWrite(transistorPinOverall, HIGH);
  digitalWrite(transistorPinLoad2, HIGH);
  digitalWrite(transistorPinLoad3, HIGH);
}

void loop() {
  handleSerialCommands();
  updateBreakerLogic();

  if (millis() - lastSendTime >= sendInterval) {
    sendDataPacket();
    lastSendTime = millis();
  }
}

void handleSerialCommands() {
  if (Serial.available() > 0) {
    uint8_t commandType = Serial.read();

    if (commandType == CMD_TOGGLE_STATE && Serial.available() >= 2) {
      uint8_t payload[2];
      Serial.readBytes(payload, 2);
      int breakerIndex = payload[0];
      bool newState = (payload[1] == 1);
      setBreakerState(breakerIndex, newState);
    } 
    else if (commandType == CMD_SET_MAX_VOLTAGE && Serial.available() >= 5) {
      uint8_t payload[5];
      Serial.readBytes(payload, 5);
      int breakerIndex = payload[0];

      if (breakerIndex > 0 && breakerIndex < 4) { // Only for loads 1-3
        union {
          float f;
          uint8_t bytes[4];
        } converter;
        memcpy(converter.bytes, &payload[1], 4);
        maxVoltages[breakerIndex] = converter.f;
      }
    }
  }
}

void updateBreakerLogic() {
  int dcLoad_sensorValue = analogRead(dcLoad_sensorPin);
  float dcLoad_voltage = (dcLoad_sensorValue * dcLoad_VoltageSlope) + dcLoad_VoltageIntercept;

  // Auto-trip logic for "Load 1" using the dynamic max voltage
  if (breakerIsOn[1] && dcLoad_voltage >= maxVoltages[1]) {
    setBreakerState(1, false); // Trip the breaker
  }
  // This logic could be expanded for other loads if they get physical sensors.
}

void setBreakerState(int index, bool isOn) {
  if (index < 0 || index > 3) return;

  if (index == 0) { // Overall breaker logic
    breakerIsOn[0] = isOn;
    digitalWrite(transistorPinOverall, isOn ? LOW : HIGH);
    if (!isOn) {
      for (int i = 1; i < 4; i++) {
        setBreakerState(i, false);
      }
    }
  } else { // Individual load breaker logic
    if (isOn && !breakerIsOn[0]) {
      return; // Cannot turn on if master is off.
    }
    breakerIsOn[index] = isOn;
    int pin = 0;
    if (index == 1) pin = transistorPinLoad1;
    if (index == 2) pin = transistorPinLoad2;
    if (index == 3) pin = transistorPinLoad3;
    digitalWrite(pin, isOn ? LOW : HIGH);
  }
}

void sendDataPacket() {
  uint8_t statusMask = 0;
  for (int i = 0; i < 4; i++) {
    if (breakerIsOn[i]) {
      statusMask |= (1 << i);
    }
  }
  
  float systemVoltage = (analogRead(dcArduino_sensorPin) * dcArduino_VoltageSlope) + dcArduino_VoltageIntercept;
  float load1Voltage = (analogRead(dcLoad_sensorPin) * dcLoad_VoltageSlope) + dcLoad_VoltageIntercept;

  uint8_t packet[21];
  packet[0] = statusMask;
  
  union {
    float f;
    uint8_t bytes[4];
  } converter;

  converter.f = systemVoltage;
  memcpy(&packet[1], converter.bytes, 4);

  converter.f = load1Voltage; // Placeholders use Load 1's voltage
  memcpy(&packet[5], converter.bytes, 4);  // Total Load
  memcpy(&packet[9], converter.bytes, 4);  // Load 1
  memcpy(&packet[13], converter.bytes, 4); // Load 2
  memcpy(&packet[17], converter.bytes, 4); // Load 3

  Serial.write(packet, sizeof(packet));
}
