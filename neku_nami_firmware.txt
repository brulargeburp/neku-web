
/**
 * Neku-Nami Control Panel Firmware (v1.1.0 - SSR Control)
 * 
 * This firmware communicates with the Neku-Nami web application using a
 * human-readable, text-based protocol. It manages two independent circuit breakers
 * via Solid State Relays (SSRs), reads sensor data for each load, and supports 
 * real-time configuration of trip thresholds.
 * 
 * --- Web App Communication Protocol (Text-based) ---
 * 
 * ---> Outgoing Data Packet to Web App --->
 * A single string line ending in a newline character ('\n').
 * Format: "statusMask|systemCurrent|totalLoadCurrent|load1Current|load2Current"
 * Example: "6|1.55|1.55|0.80|0.75"
 * - statusMask bit 0: Overall status (logical OR of loads)
 * - statusMask bit 1: Load 1 status
 * - statusMask bit 2: Load 2 status
 *
 * <--- Incoming Command Packets from Web App <---
 * Commands are simple strings ending in a newline character ('\n').
 * 1. Toggle State: "T,breakerIndex,newState" 
 *    (e.g., "T,1,1" to turn Load 1 ON)
 *    (e.g., "T,0,0" to turn ALL loads OFF)
 * 2. Set Max Current: "M,breakerIndex,maxCurrent"
 *    (e.g., "M,1,4.5" to set Load 1 max current to 4.5A)
 * 3. Set Min Current: "m,breakerIndex,minCurrent"
 *    (e.g., "m,1,0.2" to set Load 1 min current to 0.2A)
 */

// --- Pin Definitions ---
const int load1_currentSensorPin = A0; // Ammeter for Load 1
const int load2_currentSensorPin = A1; // Ammeter for Load 2
const int ssrPinLoad1 = 8;             // SSR for Load 1
const int ssrPinLoad2 = 13;            // SSR for Load 2

// --- State Management (2 Loads) ---
bool breakerIsOn[2] = {false, false};
float maxCurrents[2] = {5.0, 5.0}; // Default max current for Loads 1 & 2 is 5.0A
float minCurrents[2] = {0.1, 0.1}; // Default min current for Loads 1 & 2 is 0.1A

// --- Calibration Values (example for ACS712-20A) ---
const float sensorOffset = 2.5; 
const float sensorSensitivity = 0.100;

// --- Communication Timing ---
unsigned long lastSendTime = 0;
const long sendInterval = 100;

void setup() {
  Serial.begin(9600);
  pinMode(ssrPinLoad1, OUTPUT);
  pinMode(ssrPinLoad2, OUTPUT);
  // SSRs are typically active-low. HIGH = OFF.
  digitalWrite(ssrPinLoad1, HIGH);
  digitalWrite(ssrPinLoad2, HIGH);
}

void loop() {
  handleSerialCommands();
  updateBreakerLogic();

  if (millis() - lastSendTime >= sendInterval) {
    sendDataPacket();
    lastSendTime = millis();
  }
}

float readCurrent(int pin) {
  int sensorValue = analogRead(pin);
  float voltage = (sensorValue / 1024.0) * 5.0;
  float current = (voltage - sensorOffset) / sensorSensitivity;
  return abs(current);
}

void handleSerialCommands() {
  if (Serial.available() > 0) {
    String command = Serial.readStringUntil('\n');
    command.trim();

    if (command.length() == 0) return;

    char commandType = command.charAt(0);
    String payload = command.substring(2);
    
    int firstComma = payload.indexOf(',');
    if (firstComma == -1) return;

    int webAppIndex = payload.substring(0, firstComma).toInt();
    String valueStr = payload.substring(firstComma + 1);

    if (commandType == 'T') {
      bool newState = (valueStr.toInt() == 1);
      if (webAppIndex == 0) { // Overall breaker command
        if (!newState) { // Turn everything off
          setBreakerState(0, false);
          setBreakerState(1, false);
        }
        // "ON" command for overall breaker is ignored, as it's a logical state.
        // Individual loads must be turned on explicitly.
      } else if (webAppIndex > 0 && webAppIndex < 3) {
        int firmwareIndex = webAppIndex - 1;
        setBreakerState(firmwareIndex, newState);
      }
    } else if (commandType == 'M' || commandType == 'm') {
      if (webAppIndex > 0 && webAppIndex < 3) {
        int firmwareIndex = webAppIndex - 1;
        float value = valueStr.toFloat();
        if (commandType == 'M') {
          maxCurrents[firmwareIndex] = value;
        } else { // 'm'
          minCurrents[firmwareIndex] = value;
        }
      }
    }
  }
}

void updateBreakerLogic() {
  // Check Load 1
  if (breakerIsOn[0]) {
    float load1Current = readCurrent(load1_currentSensorPin);
    if (load1Current >= maxCurrents[0] || (load1Current > 0 && load1Current < minCurrents[0])) {
      setBreakerState(0, false);
    }
  }

  // Check Load 2
  if (breakerIsOn[1]) {
    float load2Current = readCurrent(load2_currentSensorPin);
    if (load2Current >= maxCurrents[1] || (load2Current > 0 && load2Current < minCurrents[1])) {
      setBreakerState(1, false);
    }
  }
}

void setBreakerState(int index, bool isOn) {
  if (index < 0 || index >= 2) return;

  breakerIsOn[index] = isOn;
  int pin = (index == 0) ? ssrPinLoad1 : ssrPinLoad2;
  digitalWrite(pin, isOn ? LOW : HIGH); // Active LOW for SSR
}

void sendDataPacket() {
  uint8_t statusMask = 0;
  
  if (breakerIsOn[0]) { statusMask |= (1 << 1); } // Load 1 is bit 1
  if (breakerIsOn[1]) { statusMask |= (1 << 2); } // Load 2 is bit 2
  if (statusMask > 0) { statusMask |= (1 << 0); } // Overall is bit 0, on if any load is on

  float load1Current = readCurrent(load1_currentSensorPin);
  float load2Current = readCurrent(load2_currentSensorPin);
  float totalLoadCurrent = load1Current + load2Current;
  float systemCurrent = totalLoadCurrent; // No separate system sensor
  
  String dataPacket = "";
  dataPacket += String(statusMask);
  dataPacket += "|";
  dataPacket += String(systemCurrent, 2);
  dataPacket += "|";
  dataPacket += String(totalLoadCurrent, 2);
  dataPacket += "|";
  dataPacket += String(load1Current, 2);
  dataPacket += "|";
  dataPacket += String(load2Current, 2);

  Serial.println(dataPacket);
}
